2024/04/09

//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
////假设p值为0x100000，则下方表达式分别为?
////结构体Test类型变量的大小为20字节(4+4+2+1*2+4*2)
//int main()
//{
//	p = (struct Test*)0x100000;//p为指向结构体Test类型的指针变量，存放的是地址
//	printf("%p\n", p + 0x1);//p+1，向后跳过一个结构体Test类型(20字节),即0x00100014
//	printf("%p\n", (unsigned long)p + 0x1);//p强制类型转化为整形，再+1，即0x00100001
//	printf("%p\n", (unsigned int*)p + 0x1);//p转化为整形指针，+1，向后跳一个整形指针类型（4字节），即0x00100004
//
//	return 0;
//}

//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x,%X", ptr1[-1],*ptr2);//4, win32平台上为 02000000 x64无输出
//	//a在内存中存储时为小端存储(低位对应低地址)
//	//				a[0]=1		a[1]=2		a[2]=3  	a[3]=4 | 这里可以看作数组a的下一个数组
//	//低地址		01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|？？		高地址
//	//		   ^ &a指向此处	    (&a+1就跳过了一个a数组))			^ (&a+1)指向此处
//	// 	所以指针ptr就是指向a下一个数组的首元素的地址 ptr[-1]即*(ptr-1),也就是4
//	// 
//	// (int)a就是将a数组首元素地址转化为整形；+1，也就是大小加了1；再转化为指针变量，也就是这个整型数组作为地址在使用
//	// 相较于之前未加1，现在比之前跳了一个字节
//	//				   v (此处地址为(int)a+1)  也就是说ptr2指向的是此处的地址
//	// 	//低地址		01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|？？		高地址
//	//				   ^         ^ 为对其*，补全一个int类型大小后在内存中的存储，即0x 02 00 00 00
//	return 0;
//}

//int main()
//{
//	int arr[3][2] = { (0,1),(2,3),(4,5) };//（0，1）为逗号表达式，最后arr[3][2]以先行后列的方式 只存了1、3、5三个数字
//	int* p;
//	p = arr[0];//arr[0]为这个二维数组的第一行行数组，则p存放了第一行行数组的首元素的地址，即1的地址
//	printf("%d\n", p[0]);//1   p[0] = *(p+0)即为1
//	return 0;
//}

int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;
	printf("%p,%d", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//fffffffc,-4
	return 0;
}
