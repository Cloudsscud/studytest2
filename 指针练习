2024/04/09

//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
////假设p值为0x100000，则下方表达式分别为?
////结构体Test类型变量的大小为20字节(4+4+2+1*2+4*2)
//int main()
//{
//	p = (struct Test*)0x100000;//p为指向结构体Test类型的指针变量，存放的是地址
//	printf("%p\n", p + 0x1);//p+1，向后跳过一个结构体Test类型(20字节),即0x00100014
//	printf("%p\n", (unsigned long)p + 0x1);//p强制类型转化为整形，再+1，即0x00100001
//	printf("%p\n", (unsigned int*)p + 0x1);//p转化为整形指针，+1，向后跳一个整形指针类型（4字节），即0x00100004
//
//	return 0;
//}

//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x,%X", ptr1[-1],*ptr2);//4, win32平台上为 02000000 x64无输出
//	//a在内存中存储时为小端存储(低位对应低地址)
//	//				a[0]=1		a[1]=2		a[2]=3  	a[3]=4 | 这里可以看作数组a的下一个数组
//	//低地址		01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|？？		高地址
//	//		   ^ &a指向此处	    (&a+1就跳过了一个a数组))			^ (&a+1)指向此处
//	// 	所以指针ptr就是指向a下一个数组的首元素的地址 ptr[-1]即*(ptr-1),也就是4
//	// 
//	// (int)a就是将a数组首元素地址转化为整形；+1，也就是大小加了1；再转化为指针变量，也就是这个整型数组作为地址在使用
//	// 相较于之前未加1，现在比之前跳了一个字节
//	//				   v (此处地址为(int)a+1)  也就是说ptr2指向的是此处的地址
//	// 	//低地址		01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|？？		高地址
//	//				   ^         ^ 为对其*，补全一个int类型大小后在内存中的存储，即0x 02 00 00 00
//	return 0;
//}

//int main()
//{
//	int arr[3][2] = { (0,1),(2,3),(4,5) };//（0，1）为逗号表达式，最后arr[3][2]以先行后列的方式 只存了1、3、5三个数字
//	int* p;
//	p = arr[0];//arr[0]为这个二维数组的第一行行数组，则p存放了第一行行数组的首元素的地址，即1的地址
//	printf("%d\n", p[0]);//1   p[0] = *(p+0)即为1
//	return 0;
//}

int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;
	printf("%p,%d", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//fffffffc,-4
	return 0;
}

//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);
//	//&aa+1为aa数组 后一数组 的首元素地址，内存中指向的是aa数组中元素10的后一个int类型元素地址
//	int* ptr2 = (int*)(*(aa + 1));
//	//aa为二维数组的第二行地址，aa+1为二维数组的第二行数组地址
//	//*(aa+1)为第二行行数组的首元素地址(即aa[1])，此处int*无实际意义
//	printf("%d  %d\n", *(ptr1 - 1), *(ptr2 - 1));//10  5
//	return 0;
//}

//int main()
//{
//	char* a[] = { "work","at","alibaba" };
// //字符串在数组中存放的是字符串首字符的地址
// //数组a中存放的元素分别是'w','a','a'的地址
//	char** pa = a;
// //pa指向的是a首元素的地址
//	pa++;
// //pa++后指向的是a的第二个元素的地址,*后就为数组a的第二个元素
//	printf("%s\n", *pa);//"at"
//	return 0;
//}

int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" }; 
	//数组内部存放字符串，存的是首字符的地址，%s打印自动解引用为字符
	char** cp[] = { c + 3,c + 2,c + 1,c }; 
	char*** cpp = cp;
	printf("%s\n", **++cpp); 
	//cpp为(c+3)的地址,++后为(c+2)的地址,*后为c+2,即'P'的地址,*后为'P',%s打印后为"POINT".注意！此时cpp为(c+2)的地址
	printf("%s\n", *--*++cpp + 3);
	//cpp再经++后为(c+1)的地址,*后为c+1,即'N'的地址,--后c,即'E'的地址,*后为'E',+3后为第二个'E',%s打印后为"ER".注意!此时cpp为cp[2]即(c+1) 的地址
	printf("%s\n", *cpp[-2] + 3);
	//cpp[-2]就是cp[2]向前移动2个元素后解引用,即对c+3的地址*,*后为c+3,即'F'的地址,再*后为'F',+3就是'S',%s打印后为"ST"
	printf("%s\n", cpp[-1][-1] + 1);
	//cpp[-1]就是cp[2]前移一个元素并解引用,变为c+2的地址,再[-1]就变为对c+1解引用后的,即'N',+1就是'E',%s打印后为"EW"
	return 0;
}
