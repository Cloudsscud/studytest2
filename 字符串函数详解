#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<assert.h>
//char* my_strcpy(char* dest, const char* src)
//{
//	assert(dest && src);
//	char* ret = dest;
//	//将arr2中的所有字符全部拷贝到arr1,包括'\0'
//	while (*dest++ = *src++)
//	{
//		;
//	}
//	return ret;//返回拷贝目的地地址
//}
//int main()
//{
//	char arr1 = "abcdef";
//	char arr2 = "found";
//	my_strcpy(arr1, arr2);//将arr2拷贝并替换到arr1中
//	printf("%s\n", arr1);
//	return 0;
//}

char* my_strcat(char* dest, const char* src)
{
	char* ret = dest;
	assert(dest && src);
	while (*dest != '\0')//找出要追加到的目的地的结束位置'\0'
	{
		dest++;
	}
	//将来源字符串的所有字符追加在目的地字符串的后方
	while (*dest++ = *src++)
	{
		;
	}
	return ret;//返回追加目的地的地址
}
int main()
{
	char arr1[30] = "hello ";
	char arr2[] = "world";
	my_strcat(arr1, arr2);
	printf("%s\n", arr1);
	return 0;
}

//#include<string.h>
//#include<assert.h>
//int my_strcmp(const char* p1, const char* p2)
//{
//	assert(p1 && p2);
//	while (*p1 == *p2)
//	{
//		if (*p1 == '\0')//相同
//			return 0;
//		p1++;
//		p2++;
//	}
//	//if (*p1 > *p2)
//	//	return 1;//前者大
//	//else
//	//	return -1;//后者大
//	return (*p1 - *p2);//返回差值
//}
//int main()
//{
//	char* p1 = "abcdef";
//	//char* p2 = "abcdef";
//	char* p2 = "abfjka";
//	int ret = my_strcmp(p1, p2);
//	printf("%d\n", ret);
//	return 0;
//}

//int main()
//{
//	//char arr1[7] = "abcdef";
//	//char arr2[] = "hello,world";
//	//strncpy(arr1, arr2, 3);//hel def只将arr2的前三个字符拷贝到arr1中
//	char arr1[10] = "abdefghij";
//	char arr2[10] = "qwq";
//	strncpy(arr1, arr2, 6);	//本来应该将arr2的前六个字符拷贝到arr1中，
//							//但是arr2字符数量不够，所以缺少的字符均用'\0'替代,即arr1被改为"qwq'\0''\0''\0'hij'\0'"
//	printf("%s\n", arr1);
//	return 0;
//}

//模拟实现strncpy
char* my_strncpy(char* dest, const char* src, int num)
{
	assert(dest && src);
	char* start = dest;
	while (num && (*dest++ = *src++))//要么需要拷贝的字符数量足够了(num==0)，要么将被拷贝对象src的字符全部(包括'\0')已经拷贝到了dest
	{
		num--;
	}
	//此时可能num为0，也可能num!=0但是src已经将所有字符(包括'\0')拷贝到了dest中

	if (num)//先看num是否为0
		while (--num)	//若不为0，说明被拷贝字符串字符个数不足，应在后补上'\0'
						//但是因为此种情况下 上边while结束时，已经将被拷贝对象src的'\0'拷贝到dest了,不过num并未变化
						//所以应先将num-1再进行判断是否需要额外补'\0'
			*dest++ = '\0';
	return start;//返回拷贝完后的字符串地址
}
int main()
{
	char arr1[10] = "abcdefg";
	char arr2[] = "hello world";
	my_strncpy(arr1, arr2, 5);
	printf("%s\n", arr1);
	return 0;
}

#include<stdio.h>
#include<string.h>
////strncmp
//int main()
//{
//	const char* p1 = "abcdef";
//	const char* p2 = "abcmptqsda";
//	//int ret = strncmp(p1, p2, 3);//0
//	int ret = strncmp(p1, p2, 4);//-1
//	//int ret = strcmp(p1, p2);//-1
//	printf("%d\n", ret);
//	return 0;
//}

char* my_strstr(const* p1, const char* p2)
{
	assert(p1 &&  p2);
	char* s1 = p1;
	char* s2 = p2;
	char* cur = p1;
	if (*p2 == '\0')
		return p1;
	while (*cur)
	{
		cur = s1;
		s2 = p2;
		while (*s1 != '\0' && *s2 != '\0' && *s1 == *s2)
		{
			s1++;
			s2++;
		}
		if (*s2 == '\0')
		{
			return cur;//找到子串
		}
		s1++;
	}
	return NULL;//没有子串
}

int main()
{
	char* p1 = "strstrcmpsacmpsa";
	char* p2 = "cmp";
	//char* ret = strstr(p1, p2);//若找到第一次出现的子串，则返回该串起始位置的地址
								//否则返回空指针
	char* ret = my_strstr(p1, p2);
	if (ret == NULL)
		printf("子串不存在\n");
	else
		printf("子串位置%s", ret);
	return 0;
}
